apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: k8srequirehpacheck
spec:
  crd:
    spec:
      names:
        kind: K8sRequireHPACheck
      validation:
        openAPIV3Schema:
          properties:
            message:
              type: string
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package k8srequirehpacheck

        violation[{"msg": msg}] {
          input.review.kind.kind == "Deployment" or input.review.kind.kind == "StatefulSet"
          
          # Check if HPA exists
          hpa := input.review.object.spec.template.metadata.annotations["autoscaling.alpha.kubernetes.io/hpa"]
          hpa != ""
          
          # Parse HPA annotations to get minReplicas
          minReplicas := parse_hpa(hpa).minReplicas
          
          # Condition 1 & 2: Block if minReplicas <= 1
          minReplicas <= 1
          msg := "Given the application is set to scale, you must set the HPA minReplicas value to be greater than 1."
        }

        violation[{"msg": msg}] {
          input.review.kind.kind == "Deployment" or input.review.kind.kind == "StatefulSet"
          
          # Check if HPA is absent
          not hpa_exists(input.review.object.spec.template.metadata.annotations)
          
          msg := "There is no HPA present in the Deployment or StatefulSet resource. Please consider adding one."
        }

        hpa_exists(annotations) {
          hpa := annotations["autoscaling.alpha.kubernetes.io/hpa"]
          hpa != ""
        }

        parse_hpa(hpa) = parsed {
          # This is a simplified parsing function for demonstration purposes
          # Assume HPA is provided in JSON format in the annotation (which is not typical, but used here for simplicity)
          parsed := {
            "minReplicas": hpa["minReplicas"]
          }
        }